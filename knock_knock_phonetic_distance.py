# -*- coding: utf-8 -*-
"""knock knock phonetic distance

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LYk9ptUGPYbI106mN1YpmRnxiZYu04NI
"""

# Upload the CMU dictionary "dictionary.txt" and the consonant/vowel similarity metrics "similarityC" and "similarityV" as .txt files
from google.colab import files
uploaded = files.upload()

###final version###

import itertools
import numpy as np

###CALCULATE CONSONANT DIFFERENCE VALUES###
DIFF_ROW=[]
DIFF_COL=[]
DIFF_ARRAY=[]
DIFF_INDEX=[]
vectC_file = open('similarityC.txt')
for line in vectC_file:     #search through each line in the text file
  line=line.strip()
  word = line.split(',')
  DIFF_ROW.append(word)

DIFF_COL = DIFF_ROW.copy()

for a in range(len(DIFF_ROW)):
   row = np.array(DIFF_ROW[a][1:])
   row = list(map(int, row))
   for b in range(len(DIFF_COL)):
      col = np.array(DIFF_COL[b][1:])
      col = list(map(int, col))
      raw_diff = np.subtract(row,col)
      diff = [abs(ele) for ele in raw_diff]
      DIFF_ARRAY.append(diff)
      index = str(DIFF_ROW[a][0]) + "," + str(DIFF_ROW[b][0])
      DIFF_INDEX.append(index)

###CALCULATE VOWEL DIFFERENCE VALUES###
vDIFF_ROW=[]
vDIFF_COL=[]
vDIFF_ARRAY=[]
vDIFF_INDEX=[]
vectV_file = open('similarityV.txt')
for line in vectV_file:     #search through each line in the text file
  line=line.strip()
  word = line.split(',')
  vDIFF_ROW.append(word)

vDIFF_COL = vDIFF_ROW.copy()

for a in range(len(vDIFF_ROW)):
   row = np.array(vDIFF_ROW[a][1:])
   row = list(map(int, row))
   for b in range(len(vDIFF_COL)):
      col = np.array(vDIFF_COL[b][1:])
      col = list(map(int, col))
      raw_diff = np.subtract(row,col)
      diff = [abs(ele) for ele in raw_diff]
      vDIFF_ARRAY.append(diff)
      index = str(vDIFF_ROW[a][0]) + "," + str(vDIFF_ROW[b][0])
      vDIFF_INDEX.append(index)

###INPUT LINE3/LINE5 AND CONVERT TO PHONES###

line3 = input('Line 3: ').upper() #convert all input to uppercase to correspond with dictionary
line5 = input('Line 5: ').upper()
word1 = line3.split()
word2 = line5.split()

LINE3 = ['unavailable']*len(word1)
LINE5 = ['unavailable']*len(word2)
NUCLEUS1 = []
NUCLEUS2 = []
STRESS1 = []
STRESS2 = []
POS=[]
print (word1, word2)

count = 1
for n in range(len(word1)):
  raw_file = open('dictionary.txt')
  for line in raw_file:     #search through each line in the text file
    line=line.strip()
    word = line.split()
    if word1[n] == word[0]:
      for m in word[1:]:  # changes the ER to AH R #
        if len(m) > 2:
          if m[:(len(m)-1)] == 'ER':
            POS.append(word.index(m))
            word[word.index(m)] = 'AH'+m[len(m)-1:]
      for i in POS:
        word.insert(i+count,'R')
        count = count + 1
        print (word[1:])
      LINE3[n] = word[1:]

PHONES3 = [item for sublist in LINE3 for item in sublist]     #flatten lists of phonemes into single list
for h in range(len(PHONES3)):   #remove numbers indicating stress for vowel search
        if len(PHONES3[h]) > 2:
          STRESS1.append(PHONES3[h][len(PHONES3[h])-1:])    #make list of stress values
          col = list(map(int, col))
          PHONES3[h] = PHONES3[h][:len(PHONES3[h])-1]

POS.clear()
count = 1
for n in range(len(word2)):
  raw_file = open('dictionary.txt')
  for line in raw_file:     #search through each line in the text file
    line=line.strip()
    word = line.split()
    if word2[n] == word[0]:
      for m in word[1:]:  # changes the ER to AH R #
        if len(m) > 2:
          if m[:(len(m)-1)] == 'ER':
            POS.append(word.index(m))
            word[word.index(m)] = 'AH'+m[len(m)-1:]
      for i in POS:
        word.insert(i+count,'R')
        count = count + 1
        print (word[1:])
      LINE5[n] = word[1:]
PHONES5 = [item for sublist in LINE5 for item in sublist]     #flatten lists of phonemes into single list
for h in range(len(PHONES5)):   #remove numbers indicating stress for vowel search
        if len(PHONES5[h]) > 2:
          STRESS2.append(PHONES5[h][len(PHONES5[h])-1:])    #make list of stress values
          PHONES5[h] = PHONES5[h][:len(PHONES5[h])-1]

VOWELS = ['AA', 'AE', 'AH', 'AO', 'AW', 'AX', 'AXR', 'AY', 'EH', 'ER', 'EY', 'IH', 'IX', 'IY', 'OW', 'OY', 'UH', 'UW', 'UX']
CONSONANTS = ['B', 'CH', 'D', 'DH', 'DX', 'EL', 'EM', 'EN', 'F', 'G', 'HH', 'JH', 'K', 'L', 'M', 'N', 'NG', 'P', 'Q', 'R', 'S', 'SH', 'T', 'TH', 'V', 'W', 'Y', 'Z', 'ZH']
CONS1=[]
CONS2=[]
C_VEC1=[]
C_VEC2=[]

print ("Phones list: ", PHONES3,PHONES5)

###SEGMENTS INTO SYLLABLES###
VOWEL1 = []
VOWEL2 = []
for i in range(len(PHONES3)):
  for vowel in VOWELS:
      if PHONES3[i] == vowel:
        NUCLEUS1.append(i) #this tells you the position of the vowels so you can segment the syllables
        VOWEL1.append(PHONES3[i])  #this creates a list of vowels
print ("vowels list 1: ", VOWEL1)

for j in range(len(NUCLEUS1)):
      if j == 0 and (NUCLEUS1[0] != 0):  #for the first NUCLEUS1, the syllable is everything up to the NUCLEUS1
        syll_start = NUCLEUS1[j]
        CONS1.append(PHONES3[:syll_start])
      if j != 0:  #for all other nuclei except the last, the syllable is everything up to the present NUCLEUS1 from the previous NUCLEUS1
        syll_start = NUCLEUS1[j-1]
        syll_end = NUCLEUS1[j]
        CONS1.append(PHONES3[syll_start+1:syll_end])
      if NUCLEUS1[j] == max(NUCLEUS1) and NUCLEUS1[j] != len(PHONES3)-1:
        syll_start = NUCLEUS1[j]
        CONS1.append(PHONES3[syll_start+1:])
print ("consonant list 1: ", CONS1)

for i in range(len(PHONES5)):
  for vowel in VOWELS:
      if PHONES5[i] == vowel:
        NUCLEUS2.append(i) #this tells you the position of the vowels so you can segment the syllables
        VOWEL2.append(PHONES5[i])  #this creates a list of vowels
print ("vowels list 2: ", VOWEL2)

for j in range(len(NUCLEUS2)):
      if j == 0 and (NUCLEUS1[0] != 0):  #for the first NUCLEUS2, the syllable is everything up to the NUCLEUS2
        syll_start = NUCLEUS2[j]
        CONS2.append(PHONES5[:syll_start])
      if j != 0:  #for all other nuclei except the last, the syllable is everything up to the present NUCLEUS2 from the previous NUCLEUS2
        syll_start = NUCLEUS2[j-1]
        syll_end = NUCLEUS2[j]
        CONS2.append(PHONES5[syll_start+1:syll_end])
      if NUCLEUS2[j] == max(NUCLEUS2) and NUCLEUS2[j] != len(PHONES5)-1:
        syll_start = NUCLEUS2[j]
        CONS2.append(PHONES5[syll_start+1:])
print ("consonant list 2: ", CONS2)


###DELETE EXTRA CONSONANTS AND VOWELS###
MINLIST=[]
MAXLIST=[]
MINLISTV=[]
MAXLISTV=[]
SYLL_PENALTY = []

minlen = min(len(CONS1),len(CONS2))
if len(CONS1) == minlen:
  MINLIST = CONS1.copy()
  MAXLIST = CONS2.copy()
else:
  MINLIST = CONS2.copy()
  MAXLIST = CONS1.copy()

minlen = min(len(VOWEL1),len(VOWEL2))
if len(VOWEL1) == minlen:
  MINLISTV = VOWEL1.copy()
  MAXLISTV = VOWEL2.copy()
else:
  MINLISTV = VOWEL2.copy()
  MAXLISTV = VOWEL1.copy()


c_penalty = (len(MAXLIST)-len(MINLIST)) * 10
if c_penalty > 0:
  print (" ")
  print ("oops--unequal number of consonants. Penalty: ", c_penalty)
  SYLL_PENALTY.append(c_penalty)
v_penalty = (len(MAXLISTV)-len(MINLISTV)) * 20
if v_penalty > 0:
  print (" ")
  print ("oops--unequal number of vowels. Penalty: " , v_penalty)
  SYLL_PENALTY.append(v_penalty)

SUM = []
KEEPLETTER = []
CAND1 = []
CAND2 = []
COMP = []
COMPKEY = []
MAXCOMP = []
MAXCOMPKEY = []
PENALTY=[]

for m in range(min(len(CONS1), len(CONS2))):    #this assumes your lists are equal length (i.e. same syllables) before you search
  if CONS1[m] == CONS2[m]:                      #if onsets the same, no penalty
    print (CONS1[m], "yay!")
  if CONS1[m] != CONS2[m]:   #if onsets are different
    print ("oops--", CONS1[m], " isn't equivalent to", CONS2[m])
    if len(CONS1[m]) != len(CONS2[m]): #and they are different lengths:
      minlen = min(len(CONS1[m]), len(CONS2[m]))
      if len(CONS1[m]) == minlen:
        MINSLOT = CONS1[m]
        MAXSLOT = CONS2[m]
        # MAXSLOT = [item for sublist in MAXSLOT for item in sublist]
        # MINSLOT = [item for sublist in MINSLOT for item in sublist]
        ONSET = MAXSLOT.copy()
        ONSET2 = MINSLOT.copy()
      else:
        MINSLOT = CONS2[m]
        MAXSLOT = CONS1[m]
        # MAXSLOT = [item for sublist in MAXSLOT for item in sublist]
        # MINSLOT = [item for sublist in MINSLOT for item in sublist]
        ONSET = MAXSLOT.copy()
        ONSET2 = MINSLOT.copy()

      DEL_MIN = MINSLOT.copy()    #find out if simple deletion is appropriate
      DEL_MAX = MAXSLOT.copy()
      COUNT = DEL_MIN.copy()
      for i in DEL_MIN:
        if i in DEL_MAX:
          print ("match!", i)
          COUNT.remove(i)
          PENALTY.append(10)
      if len(COUNT) == 0:
        print ("Deletion possible! Penalty: ", sum(PENALTY))
      else:                     #if deletion doesn't work and we have to use phonetic similarity:
        PENALTY.clear()
        print ("Deletion not possible! Clusters are different lengths with some letters in common")
        for k in MINSLOT:   #different lengths: if there are some letters in common, keep those
              for l in MAXSLOT:
                if k == l:
                  print ("Yes there is ", k, " in ", MAXSLOT)
                  KEEPLETTER.append(k)
        if len(KEEPLETTER) > 0:
            print ("non-candidate!: ", KEEPLETTER)
            for i in KEEPLETTER:
              if i in MAXSLOT:
                MAXSLOT.remove(i)
                print ("removed! ", MAXSLOT)
                CAND1 = MAXSLOT
              if i in MINSLOT:
                MINSLOT.remove(i)
                print ('removed! ', MINSLOT)
                CAND2 = MINSLOT
            for m in CAND1:
              for n in CAND2:
                key = str(m)+","+str(n)
                print (key)
                loc = DIFF_INDEX.index(key)
                print (DIFF_ARRAY[loc])
                diff = sum(DIFF_ARRAY[loc])
                print ("difference is: ",diff)
                MAXCOMP.append(diff)
                MAXCOMPKEY.append(m)
            for counting in range(len(CAND1) - len(CAND2)):
              print ("counting: ", counting)
              maxdiff = max(MAXCOMP)
              loc = MAXCOMP.index(maxdiff)
              print ("Removing phone", MAXCOMPKEY[loc], " :", maxdiff)
              print ("from current onset: ", ONSET)
              print (MAXCOMPKEY[loc])
              if COMPKEY[loc] in ONSET:
                ONSET.remove(COMPKEY[loc])
                COMP.remove(maxdiff)
                print ("Penalty: -10")
                PENALTY.append(10)
              print ("New onset", ONSET)
            for l in range(len(ONSET)): #for edited onset, calculating regular distance
                print (ONSET, ONSET2)
                m = ONSET[l]
                n = ONSET2[l]
                print (m, n)
                key = str(m)+","+str(n)
                print (key)
                loc = DIFF_INDEX.index(key)
                print (DIFF_ARRAY[loc])
                diff = sum(DIFF_ARRAY[loc])
                print ("difference is: ",diff)
                COMP.append(diff)
                COMPKEY.append(m)
        else: #different lengths: if there are no letters in common
            CAND1 = MAXSLOT
            CAND2 = MINSLOT
            print ("clusters are different lengths with nothing in common: ", CAND1)
            print ("clusters are different lengths with nothing in common: ", CAND2)
            for m in CAND1:
              for n in CAND2:
                key = str(m)+","+str(n)
                print (key)
                loc = DIFF_INDEX.index(key)
                print (DIFF_ARRAY[loc])
                diff = sum(DIFF_ARRAY[loc])
                print ("difference is: ",diff)
                MAXCOMP.append(diff)
                MAXCOMPKEY.append(m)
            for counting in range(len(CAND1) - len(CAND2)):
              maxdiff = max(MAXCOMP)
              loc = MAXCOMP.index(maxdiff)
              print ("Removing phone", MAXCOMPKEY[loc], " :", maxdiff)
              print ("from current onset: ", ONSET)
              if MAXCOMPKEY[loc] in ONSET:
                ONSET.remove(MAXCOMPKEY[loc])
                MAXCOMP.remove(maxdiff)
                print ("Penalty: -10")
                PENALTY.append(10)
              print (ONSET)
            for l in range(len(ONSET)): #for edited onset, calculating regular distance
              print ("Final onset: ")
              print (ONSET, ONSET2)
              m = ONSET[l]
              n = ONSET2[l]
              print (m, n)
              key = str(m)+","+str(n)
              print (key)
              loc = DIFF_INDEX.index(key)
              print (DIFF_ARRAY[loc])
              diff = sum(DIFF_ARRAY[loc])
              print ("difference is: ",diff)
              COMP.append(diff)
              COMPKEY.append(m)
    else: #if onsets are same length but different letters
            CAND1 = CONS1[m]
            CAND2 = CONS2[m]
            print ("clusters are same length but different letters: ", CAND1)
            print ("clusters are same length but different letters: ", CAND2)
            for l in range(len(CAND1)):
                m = CAND1[l]
                n = CAND2[l]
                key = str(m)+","+str(n)
                print (key)
                loc = DIFF_INDEX.index(key)
                print (DIFF_ARRAY[loc])
                diff = sum(DIFF_ARRAY[loc])
                print ("difference is: ",diff)
                COMP.append(diff)
                COMPKEY.append(m)

### CALCULATE VOWEL SIMILARITY ###
vCOMP = []
vCOMPKEY = []
print (VOWEL1, VOWEL2)
for l in range(min(len(VOWEL1), len(VOWEL2))): #for edited onset, calculating regular distance
    m = VOWEL1[l]
    n = VOWEL2[l]
    key = str(m)+","+str(n)
    print (key)
    loc = vDIFF_INDEX.index(key)
    print (vDIFF_ARRAY[loc])
    diff = sum(vDIFF_ARRAY[loc])
    print ("difference is: ",diff)
    vCOMP.append(diff)
    vCOMPKEY.append(m)

###CALCULATE STRESS PENALTIES###
DIFF_STRESS=[]
STRESS1 = list(map(int, STRESS1))
STRESS2 = list(map(int, STRESS2))

for i in range(min(len(STRESS1), len(STRESS2))):
  sdiff = STRESS1[i] - STRESS2[i]
  sdiff = abs(sdiff)
  DIFF_STRESS.append(sdiff)

print (" ")
print ("Word-final vowel/consonant deletion penalty: ", sum(SYLL_PENALTY))
print ("Consonant phonetic dissimilarity: ", COMP, "= total: ", (sum(COMP)))
print ("Consonant deletion penalty: ", sum(PENALTY))
print ("Vowel phonetic dissimilarity: ", vCOMP, "= total", (sum(vCOMP)), "x2: ", (sum(vCOMP)*2))
print ("Stress penalties: ", sum(DIFF_STRESS))
print ("FINAL WEIGHTED DISSIMILARITY: ", (sum(vCOMP)*2)+sum(COMP)+sum(DIFF_STRESS)+sum(PENALTY)+sum(SYLL_PENALTY)) #weight vowels x2

###final version (prepped for word masking)###

import itertools
import numpy as np

###CALCULATE CONSONANT DIFFERENCE VALUES###
DIFF_ROW=[]
DIFF_COL=[]
DIFF_ARRAY=[]
DIFF_INDEX=[]
vectC_file = open('similarityC.txt')
for line in vectC_file:     #search through each line in the text file
  line=line.strip()
  word = line.split(',')
  DIFF_ROW.append(word)

DIFF_COL = DIFF_ROW.copy()

for a in range(len(DIFF_ROW)):
   row = np.array(DIFF_ROW[a][1:])
   row = list(map(int, row))
   for b in range(len(DIFF_COL)):
      col = np.array(DIFF_COL[b][1:])
      col = list(map(int, col))
      raw_diff = np.subtract(row,col)
      diff = [abs(ele) for ele in raw_diff]
      DIFF_ARRAY.append(diff)
      index = str(DIFF_ROW[a][0]) + "," + str(DIFF_ROW[b][0])
      DIFF_INDEX.append(index)

###CALCULATE VOWEL DIFFERENCE VALUES###
vDIFF_ROW=[]
vDIFF_COL=[]
vDIFF_ARRAY=[]
vDIFF_INDEX=[]
vectV_file = open('similarityV.txt')
for line in vectV_file:     #search through each line in the text file
  line=line.strip()
  word = line.split(',')
  vDIFF_ROW.append(word)

vDIFF_COL = vDIFF_ROW.copy()

for a in range(len(vDIFF_ROW)):
   row = np.array(vDIFF_ROW[a][1:])
   row = list(map(int, row))
   for b in range(len(vDIFF_COL)):
      col = np.array(vDIFF_COL[b][1:])
      col = list(map(int, col))
      raw_diff = np.subtract(row,col)
      diff = [abs(ele) for ele in raw_diff]
      vDIFF_ARRAY.append(diff)
      index = str(vDIFF_ROW[a][0]) + "," + str(vDIFF_ROW[b][0])
      vDIFF_INDEX.append(index)

###INPUT LINE3/LINE5 AND CONVERT TO PHONES###
line3 = input('Line 3: ').upper() #convert all input to uppercase to correspond with dictionary
line5 = input('Line 5: ').upper()
word1 = line3.split()
word2 = line5.split()

LINE3 = ['unavailable']*len(word1)
LINE5 = ['unavailable']*len(word2)
NUCLEUS1 = []
NUCLEUS2 = []
STRESS1 = []
STRESS2 = []
POS=[]
print (word1, word2)

count = 1
for n in range(len(word1)):
  raw_file = open('dictionary.txt')
  for line in raw_file:     #search through each line in the text file
    line=line.strip()
    word = line.split()
    if word1[n] == word[0]:
      for m in word[1:]:  # changes the ER to AH R #
        POS.clear()
        if len(m) > 2:
          if m[:(len(m)-1)] == 'ER':
            POS.append(word.index(m))
            word[word.index(m)] = 'AH'+m[len(m)-1:]
        for i in POS:
          word.insert(i+count,'R')
          count = count + 1
        LINE3[n] = word[1:]

PHONES3 = [item for sublist in LINE3 for item in sublist]     #flatten lists of phonemes into single list
for h in range(len(PHONES3)):   #remove numbers indicating stress for vowel search
        if len(PHONES3[h]) > 2:
          STRESS1.append(PHONES3[h][len(PHONES3[h])-1:])    #make list of stress values
          PHONES3[h] = PHONES3[h][:len(PHONES3[h])-1]

count = 1
for n in range(len(word2)):
  if n == 5:
    break
  raw_file = open('dictionary.txt')
  for line in raw_file:     #search through each line in the text file
    line=line.strip()
    word = line.split()
    if word2[n] == word[0]:
      for m in word[1:]:  # changes the ER to AH R #
        POS.clear()
        if len(m) > 2:
          if m[:(len(m)-1)] == 'ER':
            POS.append(word.index(m))
            word[word.index(m)] = 'AH'+m[len(m)-1:]
        for i in POS:
          word.insert(i+count,'R')
          count = count + 1
        LINE5[n] = word[1:]

###IDENTIFY TARGET WORD FOR MASKING###
total = 0
for i in range(len(LINE5)):
  total = total + len(LINE5[i])
  print (total, LINE5[i])
  if total >= (len(PHONES3)):
    target = (word2[:i+1])
    context = (word2[i+1:])
    break
delimiter = " "
context = delimiter.join(context)
context = context.lower()
PHONES5 = target
target = delimiter.join(target)
target = target.lower()

print ("This is the target", target, "This is the context: ", context)


PHONES5 = [item for sublist in PHONES5 for item in sublist]     #flatten lists of phonemes into single list
for h in range(len(PHONES5)):   #remove numbers indicating stress for vowel search
        if len(PHONES5[h]) > 2:
          STRESS2.append(PHONES5[h][len(PHONES5[h])-1:])    #make list of stress values
          PHONES5[h] = PHONES5[h][:len(PHONES5[h])-1]

print ("Phones list: ", PHONES3, PHONES5)

###SEGMENTS INTO SYLLABLES###
CONS1=[]
CONS2=[]
VOWEL1 = []
VOWEL2 = []

VOWELS = ['AA', 'AE', 'AH', 'AO', 'AW', 'AX', 'AXR', 'AY', 'EH', 'ER', 'EY', 'IH', 'IX', 'IY', 'OW', 'OY', 'UH', 'UW', 'UX']
CONSONANTS = ['B', 'CH', 'D', 'DH', 'DX', 'EL', 'EM', 'EN', 'F', 'G', 'HH', 'JH', 'K', 'L', 'M', 'N', 'NG', 'P', 'Q', 'R', 'S', 'SH', 'T', 'TH', 'V', 'W', 'Y', 'Z', 'ZH']

for i in range(len(PHONES3)):
  for vowel in VOWELS:
      if PHONES3[i] == vowel:
        NUCLEUS1.append(i) #this tells you the position of the vowels so you can segment the syllables
        VOWEL1.append(PHONES3[i])  #this creates a list of vowels
print ("vowels list 1: ", VOWEL1)

for j in range(len(NUCLEUS1)):
      if j == 0 and (NUCLEUS1[0] != 0):  #for the first NUCLEUS1, the syllable is everything up to the NUCLEUS1
        syll_start = NUCLEUS1[j]
        CONS1.append(PHONES3[:syll_start])
      if j != 0:  #for all other nuclei except the last, the syllable is everything up to the present NUCLEUS1 from the previous NUCLEUS1
        syll_start = NUCLEUS1[j-1]
        syll_end = NUCLEUS1[j]
        CONS1.append(PHONES3[syll_start+1:syll_end])
      if NUCLEUS1[j] == max(NUCLEUS1) and NUCLEUS1[j] != len(PHONES3)-1:
        syll_start = NUCLEUS1[j]
        CONS1.append(PHONES3[syll_start+1:])
print ("consonant list 1: ", CONS1)

for i in range(len(PHONES5)):
  for vowel in VOWELS:
      if PHONES5[i] == vowel:
        NUCLEUS2.append(i) #this tells you the position of the vowels so you can segment the syllables
        VOWEL2.append(PHONES5[i])  #this creates a list of vowels
print ("vowels list 2: ", VOWEL2)

for j in range(len(NUCLEUS2)):
      if j == 0 and (NUCLEUS1[0] != 0):  #for the first NUCLEUS2, the syllable is everything up to the NUCLEUS2
        syll_start = NUCLEUS2[j]
        CONS2.append(PHONES5[:syll_start])
      if j != 0:  #for all other nuclei except the last, the syllable is everything up to the present NUCLEUS2 from the previous NUCLEUS2
        syll_start = NUCLEUS2[j-1]
        syll_end = NUCLEUS2[j]
        CONS2.append(PHONES5[syll_start+1:syll_end])
      if NUCLEUS2[j] == max(NUCLEUS2) and NUCLEUS2[j] != len(PHONES5)-1:
        syll_start = NUCLEUS2[j]
        CONS2.append(PHONES5[syll_start+1:])
print ("consonant list 2: ", CONS2)

###DELETE EXTRA CONSONANTS AND VOWELS###
MINLIST=[]
MAXLIST=[]
MINLISTV=[]
MAXLISTV=[]
SYLL_PENALTY = []

minlen = min(len(CONS1),len(CONS2)) #penalize for extra consonants
if len(CONS1) == minlen:
  MINLIST = CONS1.copy()
  MAXLIST = CONS2.copy()
else:
  MINLIST = CONS2.copy()
  MAXLIST = CONS1.copy()

minlen = min(len(VOWEL1),len(VOWEL2)) #penalize for extra vowels
if len(VOWEL1) == minlen:
  MINLISTV = VOWEL1.copy()
  MAXLISTV = VOWEL2.copy()
else:
  MINLISTV = VOWEL2.copy()
  MAXLISTV = VOWEL1.copy()


c_penalty = (len(MAXLIST)-len(MINLIST)) * 10
if c_penalty > 0:
  print (" ")
  print ("oops--unequal number of consonants. Penalty: ", c_penalty)
  SYLL_PENALTY.append(c_penalty)
v_penalty = (len(MAXLISTV)-len(MINLISTV)) * 20
if v_penalty > 0:
  print (" ")
  print ("oops--unequal number of vowels. Penalty: " , v_penalty)
  SYLL_PENALTY.append(v_penalty)

SUM = []
KEEPLETTER = []
CAND1 = []
CAND2 = []
COMP = []
COMPKEY = []
MAXCOMP = []
MAXCOMPKEY = []
PENALTY=[]

for m in range(min(len(CONS1), len(CONS2))):    #this assumes your lists are equal length (i.e. same syllables) before you search
  if CONS1[m] == CONS2[m]:                      #if onsets the same, no penalty
    print (CONS1[m], "yay!")
  if CONS1[m] != CONS2[m]:   #if onsets are different
    print ("oops--", CONS1[m], " isn't equivalent to", CONS2[m])
    if len(CONS1[m]) != len(CONS2[m]): #and they are different lengths:
      minlen = min(len(CONS1[m]), len(CONS2[m]))
      if len(CONS1[m]) == minlen:
        MINSLOT = CONS1[m]
        MAXSLOT = CONS2[m]
        # MAXSLOT = [item for sublist in MAXSLOT for item in sublist]
        # MINSLOT = [item for sublist in MINSLOT for item in sublist]
        ONSET = MAXSLOT.copy()
        ONSET2 = MINSLOT.copy()
      else:
        MINSLOT = CONS2[m]
        MAXSLOT = CONS1[m]
        # MAXSLOT = [item for sublist in MAXSLOT for item in sublist]
        # MINSLOT = [item for sublist in MINSLOT for item in sublist]
        ONSET = MAXSLOT.copy()
        ONSET2 = MINSLOT.copy()

      DEL_MIN = MINSLOT.copy()    #find out if simple deletion is appropriate
      DEL_MAX = MAXSLOT.copy()
      COUNT = DEL_MIN.copy()
      for i in DEL_MIN:
        if i in DEL_MAX:
          print ("match!", i)
          COUNT.remove(i)
          PENALTY.append(10)
      if len(COUNT) == 0:
        print ("Deletion possible! Penalty: ", sum(PENALTY))
      else:                     #if deletion doesn't work and we have to use phonetic similarity:
        PENALTY.clear()
        print ("Deletion not possible! Clusters are different lengths with some letters in common")
        for k in MINSLOT:   #different lengths: if there are some letters in common, keep those
              for l in MAXSLOT:
                if k == l:
                  print ("Yes there is ", k, " in ", MAXSLOT)
                  KEEPLETTER.append(k)
        if len(KEEPLETTER) > 0:
            print ("non-candidate!: ", KEEPLETTER)
            for i in KEEPLETTER:
              if i in MAXSLOT:
                MAXSLOT.remove(i)
                print ("removed! ", MAXSLOT)
                CAND1 = MAXSLOT
              if i in MINSLOT:
                MINSLOT.remove(i)
                print ('removed! ', MINSLOT)
                CAND2 = MINSLOT
            for m in CAND1:
              for n in CAND2:
                key = str(m)+","+str(n)
                print (key)
                loc = DIFF_INDEX.index(key)
                print (DIFF_ARRAY[loc])
                diff = sum(DIFF_ARRAY[loc])
                print ("difference is: ",diff)
                MAXCOMP.append(diff)
                MAXCOMPKEY.append(m)
            for counting in range(len(CAND1) - len(CAND2)):
              print ("counting: ", counting)
              maxdiff = max(MAXCOMP)
              loc = MAXCOMP.index(maxdiff)
              print ("Removing phone", MAXCOMPKEY[loc], " :", maxdiff)
              print ("from current onset: ", ONSET)
              print (MAXCOMPKEY[loc])
              if COMPKEY[loc] in ONSET:
                ONSET.remove(COMPKEY[loc])
                COMP.remove(maxdiff)
                print ("Penalty: -10")
                PENALTY.append(10)
              print ("New onset", ONSET)
            for l in range(len(ONSET)): #for edited onset, calculating regular distance
                print (ONSET, ONSET2)
                m = ONSET[l]
                n = ONSET2[l]
                print (m, n)
                key = str(m)+","+str(n)
                print (key)
                loc = DIFF_INDEX.index(key)
                print (DIFF_ARRAY[loc])
                diff = sum(DIFF_ARRAY[loc])
                print ("difference is: ",diff)
                COMP.append(diff)
                COMPKEY.append(m)
        else: #different lengths: if there are no letters in common
            CAND1 = MAXSLOT
            CAND2 = MINSLOT
            print ("clusters are different lengths with nothing in common: ", CAND1)
            print ("clusters are different lengths with nothing in common: ", CAND2)
            for m in CAND1:
              for n in CAND2:
                key = str(m)+","+str(n)
                print (key)
                loc = DIFF_INDEX.index(key)
                print (DIFF_ARRAY[loc])
                diff = sum(DIFF_ARRAY[loc])
                print ("difference is: ",diff)
                MAXCOMP.append(diff)
                MAXCOMPKEY.append(m)
            for counting in range(len(CAND1) - len(CAND2)):
              maxdiff = max(MAXCOMP)
              loc = MAXCOMP.index(maxdiff)
              print ("Removing phone", MAXCOMPKEY[loc], " :", maxdiff)
              print ("from current onset: ", ONSET)
              if MAXCOMPKEY[loc] in ONSET:
                ONSET.remove(MAXCOMPKEY[loc])
                MAXCOMP.remove(maxdiff)
                print ("Penalty: -10")
                PENALTY.append(10)
              print (ONSET)
            for l in range(len(ONSET)): #for edited onset, calculating regular distance
              print ("Final onset: ")
              print (ONSET, ONSET2)
              m = ONSET[l]
              n = ONSET2[l]
              print (m, n)
              key = str(m)+","+str(n)
              print (key)
              loc = DIFF_INDEX.index(key)
              print (DIFF_ARRAY[loc])
              diff = sum(DIFF_ARRAY[loc])
              print ("difference is: ",diff)
              COMP.append(diff)
              COMPKEY.append(m)
    else: #if onsets are same length but different letters
            CAND1 = CONS1[m]
            CAND2 = CONS2[m]
            print ("clusters are same length but different letters: ", CAND1)
            print ("clusters are same length but different letters: ", CAND2)
            for l in range(len(CAND1)):
                m = CAND1[l]
                n = CAND2[l]
                key = str(m)+","+str(n)
                print (key)
                loc = DIFF_INDEX.index(key)
                print (DIFF_ARRAY[loc])
                diff = sum(DIFF_ARRAY[loc])
                print ("difference is: ",diff)
                COMP.append(diff)
                COMPKEY.append(m)

### CALCULATE VOWEL SIMILARITY ###
vCOMP = []
vCOMPKEY = []
print (VOWEL1, VOWEL2)
for l in range(min(len(VOWEL1), len(VOWEL2))): #for edited onset, calculating regular distance
    m = VOWEL1[l]
    n = VOWEL2[l]
    key = str(m)+","+str(n)
    print (key)
    loc = vDIFF_INDEX.index(key)
    print (vDIFF_ARRAY[loc])
    diff = sum(vDIFF_ARRAY[loc])
    print ("difference is: ",diff)
    vCOMP.append(diff)
    vCOMPKEY.append(m)

###CALCULATE STRESS PENALTIES###
DIFF_STRESS=[]
STRESS1 = list(map(int, STRESS1))
STRESS2 = list(map(int, STRESS2))

for i in range(min(len(STRESS1), len(STRESS2))):
  sdiff = STRESS1[i] - STRESS2[i]
  sdiff = abs(sdiff)
  DIFF_STRESS.append(sdiff)

print (" ")
print ("Word-final vowel/consonant deletion penalty: ", sum(SYLL_PENALTY))
print ("Consonant phonetic dissimilarity: ", COMP, "= total: ", (sum(COMP)))
print ("Consonant deletion penalty: ", sum(PENALTY))
print ("Vowel phonetic dissimilarity: ", vCOMP, "= total", (sum(vCOMP)), "x2: ", (sum(vCOMP)*2))
print ("Stress penalties: ", sum(DIFF_STRESS))
print ("FINAL WEIGHTED DISSIMILARITY: ", (sum(vCOMP)*2)+sum(COMP)+sum(DIFF_STRESS)+sum(PENALTY)+sum(SYLL_PENALTY)) #weight vowels x2

###final version### - where 'ER' is parsed within the LINE and not PHONE level not to mess up the word count

import itertools
import numpy as np

###CALCULATE CONSONANT DIFFERENCE VALUES###
DIFF_ROW=[]
DIFF_COL=[]
DIFF_ARRAY=[]
DIFF_INDEX=[]
vectC_file = open('similarityC.txt')
for line in vectC_file:     #search through each line in the text file
  line=line.strip()
  word = line.split(',')
  DIFF_ROW.append(word)

DIFF_COL = DIFF_ROW.copy()

for a in range(len(DIFF_ROW)):
   row = np.array(DIFF_ROW[a][1:])
   row = list(map(int, row))
   for b in range(len(DIFF_COL)):
      col = np.array(DIFF_COL[b][1:])
      col = list(map(int, col))
      raw_diff = np.subtract(row,col)
      diff = [abs(ele) for ele in raw_diff]
      DIFF_ARRAY.append(diff)
      index = str(DIFF_ROW[a][0]) + "," + str(DIFF_ROW[b][0])
      DIFF_INDEX.append(index)

###CALCULATE VOWEL DIFFERENCE VALUES###
vDIFF_ROW=[]
vDIFF_COL=[]
vDIFF_ARRAY=[]
vDIFF_INDEX=[]
vectV_file = open('similarityV.txt')
for line in vectV_file:     #search through each line in the text file
  line=line.strip()
  word = line.split(',')
  vDIFF_ROW.append(word)

vDIFF_COL = vDIFF_ROW.copy()

for a in range(len(vDIFF_ROW)):
   row = np.array(vDIFF_ROW[a][1:])
   row = list(map(int, row))
   for b in range(len(vDIFF_COL)):
      col = np.array(vDIFF_COL[b][1:])
      col = list(map(int, col))
      raw_diff = np.subtract(row,col)
      diff = [abs(ele) for ele in raw_diff]
      vDIFF_ARRAY.append(diff)
      index = str(vDIFF_ROW[a][0]) + "," + str(vDIFF_ROW[b][0])
      vDIFF_INDEX.append(index)

###INPUT LINE3/LINE5 AND CONVERT TO PHONES###

line3 = input('Line 3: ').upper() #convert all input to uppercase to correspond with dictionary
line5 = input('Line 5: ').upper()
word1 = line3.split()
word2 = line5.split()

LINE3 = ['unavailable']*len(word1)
LINE5 = ['unavailable']*len(word2)
NUCLEUS1 = []
NUCLEUS2 = []
STRESS1 = []
STRESS2 = []
POS=[]
count = 1

for n in range(len(word1)):
  raw_file = open('dictionary.txt')
  for line in raw_file:     #search through each line in the text file
    line=line.strip()
    word = line.split()
    if word1[n] == word[0]:
      for m in word[1:]:  # changes the ER to AH R #
        if len(m) > 2:
          if m[:(len(m)-1)] == 'ER':
            POS.append(word.index(m))
            word[word.index(m)] = 'AH'+m[len(m)-1:]
      for i in POS:
        word.insert(i+count,'R')
        count = count + 1
        print (word[1:])
      LINE3[n] = word[1:]
print(LINE3)

###final version###

import itertools
import numpy as np

###CALCULATE CONSONANT DIFFERENCE VALUES###
DIFF_ROW=[]
DIFF_COL=[]
DIFF_ARRAY=[]
DIFF_INDEX=[]
vectC_file = open('similarityC.txt')
for line in vectC_file:     #search through each line in the text file
  line=line.strip()
  word = line.split(',')
  DIFF_ROW.append(word)

DIFF_COL = DIFF_ROW.copy()

for a in range(len(DIFF_ROW)):
   row = np.array(DIFF_ROW[a][1:])
   row = list(map(int, row))
   for b in range(len(DIFF_COL)):
      col = np.array(DIFF_COL[b][1:])
      col = list(map(int, col))
      raw_diff = np.subtract(row,col)
      diff = [abs(ele) for ele in raw_diff]
      DIFF_ARRAY.append(diff)
      index = str(DIFF_ROW[a][0]) + "," + str(DIFF_ROW[b][0])
      DIFF_INDEX.append(index)

###CALCULATE VOWEL DIFFERENCE VALUES###
vDIFF_ROW=[]
vDIFF_COL=[]
vDIFF_ARRAY=[]
vDIFF_INDEX=[]
vectV_file = open('similarityV.txt')
for line in vectV_file:     #search through each line in the text file
  line=line.strip()
  word = line.split(',')
  vDIFF_ROW.append(word)

vDIFF_COL = vDIFF_ROW.copy()

for a in range(len(vDIFF_ROW)):
   row = np.array(vDIFF_ROW[a][1:])
   row = list(map(int, row))
   for b in range(len(vDIFF_COL)):
      col = np.array(vDIFF_COL[b][1:])
      col = list(map(int, col))
      raw_diff = np.subtract(row,col)
      diff = [abs(ele) for ele in raw_diff]
      vDIFF_ARRAY.append(diff)
      index = str(vDIFF_ROW[a][0]) + "," + str(vDIFF_ROW[b][0])
      vDIFF_INDEX.append(index)

###INPUT LINE3/LINE5 AND CONVERT TO PHONES###

line3 = input('Line 3: ').upper() #convert all input to uppercase to correspond with dictionary
line5 = input('Line 5: ').upper()
word1 = line3.split()
word2 = line5.split()

LINE3 = ['unavailable']*len(word1)
LINE5 = ['unavailable']*len(word2)
NUCLEUS1 = []
NUCLEUS2 = []
STRESS1 = []
STRESS2 = []

for n in range(len(word1)):
  raw_file = open('dictionary.txt')
  for line in raw_file:     #search through each line in the text file
    line=line.strip()
    word = line.split()
    if word1[n] == word[0]:
      LINE3[n] = (word[1:])
PHONES3 = [item for sublist in LINE3 for item in sublist]     #flatten lists of phonemes into single list
for h in range(len(PHONES3)):   #remove numbers indicating stress for vowel search
        if len(PHONES3[h]) > 2:
          STRESS1.append(PHONES3[h][len(PHONES3[h])-1:])    #make list of stress values
          col = list(map(int, col))
          PHONES3[h] = PHONES3[h][:len(PHONES3[h])-1]

for n in range(len(word2)):
  raw_file = open('dictionary.txt')
  for line in raw_file:     #search through each line in the text file
    line=line.strip()
    word = line.split()
    if word2[n] == word[0]:
      LINE5[n] = (word[1:])
PHONES5 = [item for sublist in LINE5 for item in sublist]     #flatten lists of phonemes into single list
for h in range(len(PHONES5)):   #remove numbers indicating stress for vowel search
        if len(PHONES5[h]) > 2:
          STRESS2.append(PHONES5[h][len(PHONES5[h])-1:])    #make list of stress values
          PHONES5[h] = PHONES5[h][:len(PHONES5[h])-1]

## changes the ER to AH R ##
POS=[]
for i in range(len(PHONES3)):
  if PHONES3[i] == 'ER':
    POS.append(i)
    PHONES3[i] = 'AH'
    count = 1
    for i in POS:
      PHONES3.insert(i+count,'R')
      count = count + 1

for i in range(len(PHONES5)):
  if PHONES5[i] == 'ER':
    POS.append(i)
    PHONES5[i] = 'AH'
    count = 1
    for i in POS:
      PHONES5.insert(i+count,'R')
      count = count + 1

VOWELS = ['AA', 'AE', 'AH', 'AO', 'AW', 'AX', 'AXR', 'AY', 'EH', 'ER', 'EY', 'IH', 'IX', 'IY', 'OW', 'OY', 'UH', 'UW', 'UX']
CONSONANTS = ['B', 'CH', 'D', 'DH', 'DX', 'EL', 'EM', 'EN', 'F', 'G', 'HH', 'JH', 'K', 'L', 'M', 'N', 'NG', 'P', 'Q', 'R', 'S', 'SH', 'T', 'TH', 'V', 'W', 'Y', 'Z', 'ZH']
CONS1=[]
CONS2=[]
C_VEC1=[]
C_VEC2=[]

print ("Phones list: ", PHONES3,PHONES5)

###SEGMENTS INTO SYLLABLES###
VOWEL1 = []
VOWEL2 = []
for i in range(len(PHONES3)):
  for vowel in VOWELS:
      if PHONES3[i] == vowel:
        NUCLEUS1.append(i) #this tells you the position of the vowels so you can segment the syllables
        VOWEL1.append(PHONES3[i])  #this creates a list of vowels
print ("vowels list 1: ", VOWEL1)

for j in range(len(NUCLEUS1)):
      if j == 0 and (NUCLEUS1[0] != 0):  #for the first NUCLEUS1, the syllable is everything up to the NUCLEUS1
        syll_start = NUCLEUS1[j]
        CONS1.append(PHONES3[:syll_start])
      if j != 0:  #for all other nuclei except the last, the syllable is everything up to the present NUCLEUS1 from the previous NUCLEUS1
        syll_start = NUCLEUS1[j-1]
        syll_end = NUCLEUS1[j]
        CONS1.append(PHONES3[syll_start+1:syll_end])
      if NUCLEUS1[j] == max(NUCLEUS1) and NUCLEUS1[j] != len(PHONES3)-1:
        syll_start = NUCLEUS1[j]
        CONS1.append(PHONES3[syll_start+1:])
print ("consonant list 1: ", CONS1)

for i in range(len(PHONES5)):
  for vowel in VOWELS:
      if PHONES5[i] == vowel:
        NUCLEUS2.append(i) #this tells you the position of the vowels so you can segment the syllables
        VOWEL2.append(PHONES5[i])  #this creates a list of vowels
print ("vowels list 2: ", VOWEL2)

for j in range(len(NUCLEUS2)):
      if j == 0 and (NUCLEUS1[0] != 0):  #for the first NUCLEUS2, the syllable is everything up to the NUCLEUS2
        syll_start = NUCLEUS2[j]
        CONS2.append(PHONES5[:syll_start])
      if j != 0:  #for all other nuclei except the last, the syllable is everything up to the present NUCLEUS2 from the previous NUCLEUS2
        syll_start = NUCLEUS2[j-1]
        syll_end = NUCLEUS2[j]
        CONS2.append(PHONES5[syll_start+1:syll_end])
      if NUCLEUS2[j] == max(NUCLEUS2) and NUCLEUS2[j] != len(PHONES5)-1:
        syll_start = NUCLEUS2[j]
        CONS2.append(PHONES5[syll_start+1:])
print ("consonant list 2: ", CONS2)


###DELETE EXTRA CONSONANTS AND VOWELS###
MINLIST=[]
MAXLIST=[]
MINLISTV=[]
MAXLISTV=[]
SYLL_PENALTY = []

minlen = min(len(CONS1),len(CONS2))
if len(CONS1) == minlen:
  MINLIST = CONS1.copy()
  MAXLIST = CONS2.copy()
else:
  MINLIST = CONS2.copy()
  MAXLIST = CONS1.copy()

minlen = min(len(VOWEL1),len(VOWEL2))
if len(VOWEL1) == minlen:
  MINLISTV = VOWEL1.copy()
  MAXLISTV = VOWEL2.copy()
else:
  MINLISTV = VOWEL2.copy()
  MAXLISTV = VOWEL1.copy()


c_penalty = (len(MAXLIST)-len(MINLIST)) * 10
if c_penalty > 0:
  print (" ")
  print ("oops--unequal number of consonants. Penalty: ", c_penalty)
  SYLL_PENALTY.append(c_penalty)
v_penalty = (len(MAXLISTV)-len(MINLISTV)) * 20
if v_penalty > 0:
  print (" ")
  print ("oops--unequal number of vowels. Penalty: " , v_penalty)
  SYLL_PENALTY.append(v_penalty)

SUM = []
KEEPLETTER = []
CAND1 = []
CAND2 = []
COMP = []
COMPKEY = []
MAXCOMP = []
MAXCOMPKEY = []
PENALTY=[]

for m in range(min(len(CONS1), len(CONS2))):    #make sure your lists are equal length (i.e. same syllables) before you search
  if CONS1[m] == CONS2[m]:                      #if onsets the same, no penalty
    print (CONS1[m], "yay!")
  if CONS1[m] != CONS2[m]:   #if onsets are different
    print ("oops--", CONS1[m], " isn't equivalent to", CONS2[m])
    if len(CONS1[m]) != len(CONS2[m]): #and they are different lengths:
      minlen = min(len(CONS1[m]), len(CONS2[m]))
      if len(CONS1[m]) == minlen:
        MINSLOT = CONS1[m]
        MAXSLOT = CONS2[m]
        MAXSLOT = [item for sublist in MAXSLOT for item in sublist]
        MINSLOT = [item for sublist in MINSLOT for item in sublist]
        ONSET = MAXSLOT.copy()
        ONSET2 = MINSLOT.copy()
      else:
        MINSLOT = CONS2[m]
        MAXSLOT = CONS1[m]
        MAXSLOT = [item for sublist in MAXSLOT for item in sublist]
        MINSLOT = [item for sublist in MINSLOT for item in sublist]
        ONSET = MAXSLOT.copy()
        ONSET2 = MINSLOT.copy()

      DEL_MIN = MINSLOT.copy()    #find out if simple deletion is appropriate
      DEL_MAX = MAXSLOT.copy()
      COUNT = DEL_MIN.copy()
      for i in DEL_MIN:
        if i in DEL_MAX:
          print ("match!", i)
          COUNT.remove(i)
          PENALTY.append(10)
      if len(COUNT) == 0:
        print ("Deletion possible! Penalty: ", sum(PENALTY))
      else:                     #if deletion doesn't work and we have to use phonetic similarity:
        PENALTY.clear()
        print ("Deletion not possible! Clusters are different lengths with some letters in common")
        for k in MINSLOT:   #different lengths: if there are some letters in common, keep those
              for l in MAXSLOT:
                if k == l:
                  print ("Yes there is ", k, " in ", MAXSLOT)
                  KEEPLETTER.append(k)
        if len(KEEPLETTER) > 0:
            print ("non-candidate!: ", KEEPLETTER)
            for i in KEEPLETTER:
              if i in MAXSLOT:
                MAXSLOT.remove(i)
                print ("removed! ", MAXSLOT)
                CAND1 = MAXSLOT
              if i in MINSLOT:
                MINSLOT.remove(i)
                print ('removed! ', MINSLOT)
                CAND2 = MINSLOT
            for m in CAND1:
              for n in CAND2:
                key = str(m)+","+str(n)
                print (key)
                loc = DIFF_INDEX.index(key)
                print (DIFF_ARRAY[loc])
                diff = sum(DIFF_ARRAY[loc])
                print ("difference is: ",diff)
                MAXCOMP.append(diff)
                MAXCOMPKEY.append(m)
            for counting in range(len(CAND1) - len(CAND2)):
              print ("counting: ", counting)
              maxdiff = max(MAXCOMP)
              loc = MAXCOMP.index(maxdiff)
              print ("Removing phone", MAXCOMPKEY[loc], " :", maxdiff)
              print ("from current onset: ", ONSET)
              print (MAXCOMPKEY[loc])
              if COMPKEY[loc] in ONSET:
                ONSET.remove(COMPKEY[loc])
                COMP.remove(maxdiff)
                print ("Penalty: -10")
                PENALTY.append(10)
              print ("New onset", ONSET)
            for l in range(len(ONSET)): #for edited onset, calculating regular distance
                print (ONSET, ONSET2)
                m = ONSET[l]
                n = ONSET2[l]
                print (m, n)
                key = str(m)+","+str(n)
                print (key)
                loc = DIFF_INDEX.index(key)
                print (DIFF_ARRAY[loc])
                diff = sum(DIFF_ARRAY[loc])
                print ("difference is: ",diff)
                COMP.append(diff)
                COMPKEY.append(m)
        else: #different lengths: if there are no letters in common
            CAND1 = MAXSLOT
            CAND2 = MINSLOT
            print ("clusters are different lengths with nothing in common: ", CAND1)
            print ("clusters are different lengths with nothing in common: ", CAND2)
            for m in CAND1:
              for n in CAND2:
                key = str(m)+","+str(n)
                print (key)
                loc = DIFF_INDEX.index(key)
                print (DIFF_ARRAY[loc])
                diff = sum(DIFF_ARRAY[loc])
                print ("difference is: ",diff)
                MAXCOMP.append(diff)
                MAXCOMPKEY.append(m)
            for counting in range(len(CAND1) - len(CAND2)):
              maxdiff = max(MAXCOMP)
              loc = MAXCOMP.index(maxdiff)
              print ("Removing phone", MAXCOMPKEY[loc], " :", maxdiff)
              print ("from current onset: ", ONSET)
              if MAXCOMPKEY[loc] in ONSET:
                ONSET.remove(MAXCOMPKEY[loc])
                MAXCOMP.remove(maxdiff)
                print ("Penalty: -10")
                PENALTY.append(10)
              print (ONSET)
            for l in range(len(ONSET)): #for edited onset, calculating regular distance
              print ("Final onset: ")
              print (ONSET, ONSET2)
              m = ONSET[l]
              n = ONSET2[l]
              print (m, n)
              key = str(m)+","+str(n)
              print (key)
              loc = DIFF_INDEX.index(key)
              print (DIFF_ARRAY[loc])
              diff = sum(DIFF_ARRAY[loc])
              print ("difference is: ",diff)
              COMP.append(diff)
              COMPKEY.append(m)
    else: #if onsets are same length but different letters
            CAND1 = CONS1[m]
            CAND2 = CONS2[m]
            print ("clusters are same length but different letters: ", CAND1)
            print ("clusters are same length but different letters: ", CAND2)
            for l in range(len(CAND1)):
                m = CAND1[l]
                n = CAND2[l]
                key = str(m)+","+str(n)
                print (key)
                loc = DIFF_INDEX.index(key)
                print (DIFF_ARRAY[loc])
                diff = sum(DIFF_ARRAY[loc])
                print ("difference is: ",diff)
                COMP.append(diff)
                COMPKEY.append(m)

### CALCULATE VOWEL SIMILARITY ###
vCOMP = []
vCOMPKEY = []
print (VOWEL1, VOWEL2)
for l in range(min(len(VOWEL1), len(VOWEL2))): #for edited onset, calculating regular distance
    m = VOWEL1[l]
    n = VOWEL2[l]
    key = str(m)+","+str(n)
    print (key)
    loc = vDIFF_INDEX.index(key)
    print (vDIFF_ARRAY[loc])
    diff = sum(vDIFF_ARRAY[loc])
    print ("difference is: ",diff)
    vCOMP.append(diff)
    vCOMPKEY.append(m)

###CALCULATE STRESS PENALTIES###
DIFF_STRESS=[]
STRESS1 = list(map(int, STRESS1))
STRESS2 = list(map(int, STRESS2))

for i in range(min(len(STRESS1), len(STRESS2))):
  sdiff = STRESS1[i] - STRESS2[i]
  sdiff = abs(sdiff)
  DIFF_STRESS.append(sdiff)

print (" ")
print ("Word-final vowel/consonant deletion penalty: ", sum(SYLL_PENALTY))
print ("Consonant phonetic dissimilarity: ", COMP, "= total: ", (sum(COMP)))
print ("Consonant deletion penalty: ", sum(PENALTY))
print ("Vowel phonetic dissimilarity: ", vCOMP, "= total", (sum(vCOMP)), "x2: ", (sum(vCOMP)*2))
print ("Stress penalties: ", sum(DIFF_STRESS))
print ("FINAL WEIGHTED DISSIMILARITY: ", (sum(vCOMP)*2)+sum(COMP)+sum(DIFF_STRESS)+sum(PENALTY)+sum(SYLL_PENALTY)) #weight vowels x2

###final version### (backup where I'm not creating a copy of LINE3/LINE5 before parsing into phones)

import itertools
import numpy as np

###CALCULATE CONSONANT DIFFERENCE VALUES###
DIFF_ROW=[]
DIFF_COL=[]
DIFF_ARRAY=[]
DIFF_INDEX=[]
vectC_file = open('similarityC.txt')
for line in vectC_file:     #search through each line in the text file
  line=line.strip()
  word = line.split(',')
  DIFF_ROW.append(word)

DIFF_COL = DIFF_ROW.copy()

for a in range(len(DIFF_ROW)):
   row = np.array(DIFF_ROW[a][1:])
   row = list(map(int, row))
   for b in range(len(DIFF_COL)):
      col = np.array(DIFF_COL[b][1:])
      col = list(map(int, col))
      raw_diff = np.subtract(row,col)
      diff = [abs(ele) for ele in raw_diff]
      DIFF_ARRAY.append(diff)
      index = str(DIFF_ROW[a][0]) + "," + str(DIFF_ROW[b][0])
      DIFF_INDEX.append(index)

###CALCULATE VOWEL DIFFERENCE VALUES###
vDIFF_ROW=[]
vDIFF_COL=[]
vDIFF_ARRAY=[]
vDIFF_INDEX=[]
vectV_file = open('similarityV.txt')
for line in vectV_file:     #search through each line in the text file
  line=line.strip()
  word = line.split(',')
  vDIFF_ROW.append(word)

vDIFF_COL = vDIFF_ROW.copy()

for a in range(len(vDIFF_ROW)):
   row = np.array(vDIFF_ROW[a][1:])
   row = list(map(int, row))
   for b in range(len(vDIFF_COL)):
      col = np.array(vDIFF_COL[b][1:])
      col = list(map(int, col))
      raw_diff = np.subtract(row,col)
      diff = [abs(ele) for ele in raw_diff]
      vDIFF_ARRAY.append(diff)
      index = str(vDIFF_ROW[a][0]) + "," + str(vDIFF_ROW[b][0])
      vDIFF_INDEX.append(index)

###INPUT LINE3/LINE5 AND CONVERT TO PHONES###

line3 = input('Line 3: ').upper() #convert all input to uppercase to correspond with dictionary
line5 = input('Line 5: ').upper()
word1 = line3.split()
word2 = line5.split()

LINE3 = ['unavailable']*len(word1)
LINE5 = ['unavailable']*len(word2)
NUCLEUS1 = []
NUCLEUS2 = []
STRESS1 = []
STRESS2 = []

for n in range(len(word1)):
  raw_file = open('dictionary.txt')
  for line in raw_file:     #search through each line in the text file
    line=line.strip()
    word = line.split()
    if word1[n] == word[0]:
      LINE3[n] = (word[1:])
LINE3 = [item for sublist in LINE3 for item in sublist]     #flatten lists of phonemes into single list
PHONES3 = LINE3.copy()
for h in range(len(LINE3)):   #remove numbers indicating stress for vowel search
        if len(LINE3[h]) > 2:
          STRESS1.append(LINE3[h][len(LINE3[h])-1:])    #make list of stress values
          col = list(map(int, col))
          PHONES3[h] = PHONES3[h][:len(LINE3[h])-1]

for n in range(len(word2)):
  raw_file = open('dictionary.txt')
  for line in raw_file:     #search through each line in the text file
    line=line.strip()
    word = line.split()
    if word2[n] == word[0]:
      LINE5[n] = (word[1:])
LINE5 = [item for sublist in LINE5 for item in sublist]     #flatten lists of phonemes into single list
PHONES5 = LINE5.copy()
for h in range(len(LINE5)):   #remove numbers indicating stress for vowel search
        if len(LINE5[h]) > 2:
          STRESS2.append(LINE5[h][len(LINE5[h])-1:])    #make list of stress values
          PHONES5[h] = PHONES5[h][:len(LINE5[h])-1]

## changes the ER to AH R ##
POS=[]
for i in range(len(PHONES3)):
  if PHONES3[i] == 'ER':
    POS.append(i)
    PHONES3[i] = 'AH'
    count = 1
    for i in POS:
      PHONES3.insert(i+count,'R')
      count = count + 1

for i in range(len(PHONES5)):
  if PHONES5[i] == 'ER':
    POS.append(i)
    PHONES5[i] = 'AH'
    count = 1
    for i in POS:
      PHONES5.insert(i+count,'R')
      count = count + 1

VOWELS = ['AA', 'AE', 'AH', 'AO', 'AW', 'AX', 'AXR', 'AY', 'EH', 'ER', 'EY', 'IH', 'IX', 'IY', 'OW', 'OY', 'UH', 'UW', 'UX']
CONSONANTS = ['B', 'CH', 'D', 'DH', 'DX', 'EL', 'EM', 'EN', 'F', 'G', 'HH', 'JH', 'K', 'L', 'M', 'N', 'NG', 'P', 'Q', 'R', 'S', 'SH', 'T', 'TH', 'V', 'W', 'Y', 'Z', 'ZH']
CONS1=[]
CONS2=[]
C_VEC1=[]
C_VEC2=[]

print ("Phone list: ", PHONES3,PHONES5)

###SEGMENTS INTO SYLLABLES###
VOWEL1 = []
VOWEL2 = []
for i in range(len(PHONES3)):
  for vowel in VOWELS:
      if PHONES3[i] == vowel:
        NUCLEUS1.append(i) #this tells you the position of the vowels so you can segment the syllables
        VOWEL1.append(PHONES3[i])  #this creates a list of vowels
print ("vowels list 1: ", VOWEL1)

for j in range(len(NUCLEUS1)):
      if j == 0 and (NUCLEUS1[0] != 0):  #for the first NUCLEUS1, the syllable is everything up to the NUCLEUS1
        syll_start = NUCLEUS1[j]
        CONS1.append(PHONES3[:syll_start])
      if j != 0:  #for all other nuclei except the last, the syllable is everything up to the present NUCLEUS1 from the previous NUCLEUS1
        syll_start = NUCLEUS1[j-1]
        syll_end = NUCLEUS1[j]
        CONS1.append(PHONES3[syll_start+1:syll_end])
      if NUCLEUS1[j] == max(NUCLEUS1) and NUCLEUS1[j] != len(PHONES3)-1:
        syll_start = NUCLEUS1[j]
        CONS1.append(PHONES3[syll_start+1:])
print ("consonant list 1: ", CONS1)

for i in range(len(PHONES5)):
  for vowel in VOWELS:
      if PHONES5[i] == vowel:
        NUCLEUS2.append(i) #this tells you the position of the vowels so you can segment the syllables
        VOWEL2.append(PHONES5[i])  #this creates a list of vowels
print ("vowels list 2: ", VOWEL2)

for j in range(len(NUCLEUS2)):
      if j == 0 and (NUCLEUS1[0] != 0):  #for the first NUCLEUS2, the syllable is everything up to the NUCLEUS2
        syll_start = NUCLEUS2[j]
        CONS2.append(PHONES5[:syll_start])
      if j != 0:  #for all other nuclei except the last, the syllable is everything up to the present NUCLEUS2 from the previous NUCLEUS2
        syll_start = NUCLEUS2[j-1]
        syll_end = NUCLEUS2[j]
        CONS2.append(PHONES5[syll_start+1:syll_end])
      if NUCLEUS2[j] == max(NUCLEUS2) and NUCLEUS2[j] != len(PHONES5)-1:
        syll_start = NUCLEUS2[j]
        CONS2.append(PHONES5[syll_start+1:])
print ("consonant list 2: ", CONS2)


###DELETE EXTRA CONSONANTS AND VOWELS###
MINLIST=[]
MAXLIST=[]
MINLISTV=[]
MAXLISTV=[]
SYLL_PENALTY = []

minlen = min(len(CONS1),len(CONS2))
if len(CONS1) == minlen:
  MINLIST = CONS1.copy()
  MAXLIST = CONS2.copy()
else:
  MINLIST = CONS2.copy()
  MAXLIST = CONS1.copy()

minlen = min(len(VOWEL1),len(VOWEL2))
if len(VOWEL1) == minlen:
  MINLISTV = VOWEL1.copy()
  MAXLISTV = VOWEL2.copy()
else:
  MINLISTV = VOWEL2.copy()
  MAXLISTV = VOWEL1.copy()


c_penalty = (len(MAXLIST)-len(MINLIST)) * 10
if c_penalty > 0:
  print (" ")
  print ("oops--unequal number of consonants. Penalty: ", c_penalty)
  SYLL_PENALTY.append(c_penalty)
v_penalty = (len(MAXLISTV)-len(MINLISTV)) * 20
if v_penalty > 0:
  print (" ")
  print ("oops--unequal number of vowels. Penalty: " , v_penalty)
  SYLL_PENALTY.append(v_penalty)

SUM = []
KEEPLETTER = []
CAND1 = []
CAND2 = []
COMP = []
COMPKEY = []
MAXCOMP = []
MAXCOMPKEY = []
PENALTY=[]

for m in range(min(len(CONS1), len(CONS2))):    #make sure your lists are equal length (i.e. same syllables) before you search
  if CONS1[m] == CONS2[m]:                      #if onsets the same, no penalty
    print (CONS1[m], "yay!")
  if CONS1[m] != CONS2[m]:   #if onsets are different
    print ("oops--", CONS1[m], " isn't equivalent to", CONS2[m])
    if len(CONS1[m]) != len(CONS2[m]): #and they are different lengths:
      minlen = min(len(CONS1[m]), len(CONS2[m]))
      if len(CONS1[m]) == minlen:
        MINSLOT = CONS1[m]
        MAXSLOT = CONS2[m]
        MAXSLOT = [item for sublist in MAXSLOT for item in sublist]
        MINSLOT = [item for sublist in MINSLOT for item in sublist]
        ONSET = MAXSLOT.copy()
        ONSET2 = MINSLOT.copy()
      else:
        MINSLOT = CONS2[m]
        MAXSLOT = CONS1[m]
        MAXSLOT = [item for sublist in MAXSLOT for item in sublist]
        MINSLOT = [item for sublist in MINSLOT for item in sublist]
        ONSET = MAXSLOT.copy()
        ONSET2 = MINSLOT.copy()

      DEL_MIN = MINSLOT.copy()    #find out if simple deletion is appropriate
      DEL_MAX = MAXSLOT.copy()
      COUNT = DEL_MIN.copy()
      for i in DEL_MIN:
        if i in DEL_MAX:
          print ("match!", i)
          COUNT.remove(i)
          PENALTY.append(10)
      if len(COUNT) == 0:
        print ("Deletion possible! Penalty: ", sum(PENALTY))
      else:                     #if deletion doesn't work and we have to use phonetic similarity:
        PENALTY.clear()
        print ("Deletion not possible! Clusters are different lengths with some letters in common")
        for k in MINSLOT:   #different lengths: if there are some letters in common, keep those
              for l in MAXSLOT:
                if k == l:
                  print ("Yes there is ", k, " in ", MAXSLOT)
                  KEEPLETTER.append(k)
        if len(KEEPLETTER) > 0:
            print ("non-candidate!: ", KEEPLETTER)
            for i in KEEPLETTER:
              if i in MAXSLOT:
                MAXSLOT.remove(i)
                print ("removed! ", MAXSLOT)
                CAND1 = MAXSLOT
              if i in MINSLOT:
                MINSLOT.remove(i)
                print ('removed! ', MINSLOT)
                CAND2 = MINSLOT
            for m in CAND1:
              for n in CAND2:
                key = str(m)+","+str(n)
                print (key)
                loc = DIFF_INDEX.index(key)
                print (DIFF_ARRAY[loc])
                diff = sum(DIFF_ARRAY[loc])
                print ("difference is: ",diff)
                MAXCOMP.append(diff)
                MAXCOMPKEY.append(m)
            for counting in range(len(CAND1) - len(CAND2)):
              print ("counting: ", counting)
              maxdiff = max(MAXCOMP)
              loc = MAXCOMP.index(maxdiff)
              print ("Removing phone", MAXCOMPKEY[loc], " :", maxdiff)
              print ("from current onset: ", ONSET)
              print (MAXCOMPKEY[loc])
              if COMPKEY[loc] in ONSET:
                ONSET.remove(COMPKEY[loc])
                COMP.remove(maxdiff)
                print ("Penalty: -10")
                PENALTY.append(10)
              print ("New onset", ONSET)
            for l in range(len(ONSET)): #for edited onset, calculating regular distance
                print (ONSET, ONSET2)
                m = ONSET[l]
                n = ONSET2[l]
                print (m, n)
                key = str(m)+","+str(n)
                print (key)
                loc = DIFF_INDEX.index(key)
                print (DIFF_ARRAY[loc])
                diff = sum(DIFF_ARRAY[loc])
                print ("difference is: ",diff)
                COMP.append(diff)
                COMPKEY.append(m)
        else: #different lengths: if there are no letters in common
            CAND1 = MAXSLOT
            CAND2 = MINSLOT
            print ("clusters are different lengths with nothing in common: ", CAND1)
            print ("clusters are different lengths with nothing in common: ", CAND2)
            for m in CAND1:
              for n in CAND2:
                key = str(m)+","+str(n)
                print (key)
                loc = DIFF_INDEX.index(key)
                print (DIFF_ARRAY[loc])
                diff = sum(DIFF_ARRAY[loc])
                print ("difference is: ",diff)
                MAXCOMP.append(diff)
                MAXCOMPKEY.append(m)
            for counting in range(len(CAND1) - len(CAND2)):
              maxdiff = max(MAXCOMP)
              loc = MAXCOMP.index(maxdiff)
              print ("Removing phone", MAXCOMPKEY[loc], " :", maxdiff)
              print ("from current onset: ", ONSET)
              if MAXCOMPKEY[loc] in ONSET:
                ONSET.remove(MAXCOMPKEY[loc])
                MAXCOMP.remove(maxdiff)
                print ("Penalty: -10")
                PENALTY.append(10)
              print (ONSET)
            for l in range(len(ONSET)): #for edited onset, calculating regular distance
              print ("Final onset: ")
              print (ONSET, ONSET2)
              m = ONSET[l]
              n = ONSET2[l]
              print (m, n)
              key = str(m)+","+str(n)
              print (key)
              loc = DIFF_INDEX.index(key)
              print (DIFF_ARRAY[loc])
              diff = sum(DIFF_ARRAY[loc])
              print ("difference is: ",diff)
              COMP.append(diff)
              COMPKEY.append(m)
    else: #if onsets are same length but different letters
            CAND1 = CONS1[m]
            CAND2 = CONS2[m]
            print ("clusters are same length but different letters: ", CAND1)
            print ("clusters are same length but different letters: ", CAND2)
            for l in range(len(CAND1)):
                m = CAND1[l]
                n = CAND2[l]
                key = str(m)+","+str(n)
                print (key)
                loc = DIFF_INDEX.index(key)
                print (DIFF_ARRAY[loc])
                diff = sum(DIFF_ARRAY[loc])
                print ("difference is: ",diff)
                COMP.append(diff)
                COMPKEY.append(m)

### CALCULATE VOWEL SIMILARITY ###
vCOMP = []
vCOMPKEY = []
print (VOWEL1, VOWEL2)
for l in range(min(len(VOWEL1), len(VOWEL2))): #for edited onset, calculating regular distance
    m = VOWEL1[l]
    n = VOWEL2[l]
    key = str(m)+","+str(n)
    print (key)
    loc = vDIFF_INDEX.index(key)
    print (vDIFF_ARRAY[loc])
    diff = sum(vDIFF_ARRAY[loc])
    print ("difference is: ",diff)
    vCOMP.append(diff)
    vCOMPKEY.append(m)

###CALCULATE STRESS PENALTIES###
DIFF_STRESS=[]
STRESS1 = list(map(int, STRESS1))
STRESS2 = list(map(int, STRESS2))

for i in range(min(len(STRESS1), len(STRESS2))):
  sdiff = STRESS1[i] - STRESS2[i]
  sdiff = abs(sdiff)
  DIFF_STRESS.append(sdiff)

print (" ")
print ("Word-final vowel/consonant deletion penalty: ", sum(SYLL_PENALTY))
print ("Consonant phonetic dissimilarity: ", COMP, "= total: ", (sum(COMP)))
print ("Consonant deletion penalty: ", sum(PENALTY))
print ("Vowel phonetic dissimilarity: ", vCOMP, "= total", (sum(vCOMP)), "x2: ", (sum(vCOMP)*2))
print ("Stress penalties: ", sum(DIFF_STRESS))
print ("FINAL WEIGHTED DISSIMILARITY: ", (sum(vCOMP)*2)+sum(COMP)+sum(DIFF_STRESS)+sum(PENALTY)+sum(SYLL_PENALTY)) #weight vowels x2